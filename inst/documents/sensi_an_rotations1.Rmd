---
title: "sensi_an_rotations1. Start of sensitivity analysis for rotations."
output: pdf_document
#output: word_document
author: "Andy South and Ian Hastings"
date: "`r Sys.Date()`"
---


```{r, echo=FALSE, results='hide', warning=FALSE, message=FALSE}
  library(rotations)
  library(ggplot2)

  outFolder <- "C:\\Dropbox\\resistanceResults\\rotations\\"
```

Starting question : is there any benefit to rotations when there are no costs and no migration to an untreated area ?

Test 1. No refugia (i.e. Coverage=100%) or fitness costs. Would expect all policies to be equivalent.

Test 2. Dominance of resistance and fitness costs both set to 0.5.
I suspect one of the advantages of rotations (and the presence of refugia) is that they maintain lower resistance allele frequencies which slows the spread of recessive resistance alleles. I suspect/guess/intuit that if we make them semi-dominate these effects should disappear and all policies should be the same. I’m probably wrong but it’s a nice test…..


Testing sensitvity analysis to answer question 1. Are sequences and rotations equivalent when coverage 100% and no fitness costs. On each page should see a run with 1 set of inputs first for sequence then for rotation.

\pagebreak

```{r, eval=TRUE, echo=FALSE, warning=FALSE, message=FALSE, fig.width=9, fig.height=4}
#results='hide',

#start small & build it up
#maybe create an equiv. of resistance::sensiAnPaperPart.r later

# example for 1 run
# linputs <- list(max_gen = 50, n_insecticides = 2)
# do.call(run_rot, linputs)
# dfinputs <- as.data.frame(linputs)

# So one way of doing is to create an linputs list for each run & pass to run_rot()
# so run_rot() only ever runs for 1 scenario
# in contrast resistance::runModel2() accepted an input matrix & would run for multiple scenarios
# not sure which is better

n_scenarios <- 100

df_res_all <- data.frame()

for(i in 1:n_scenarios)
{
  # inputs (could also be saved to a dataframe first & extracted one row at a time)
  linputs <- list()
  # constant inputs
  # for Ians Q1 set coverage to 1 & cost to 0 
  linputs$coverage <- 1
  #linputs$migration <- 0.1
  linputs$cost <- 0.1 #0
  linputs$max_gen <- 400
  # variable inputs
  linputs$expo_hi <-  runif(1, min=0.1, max=0.9)
  linputs$eff <-      runif(1, min=0.3, max=1)
  
  # because I want to compare sequence rot_when_r to rotation
  # I could run all the scenarios above for both seq & rot
  # (and filter out later)

  #random rot interval integer
  linputs$rot_interval <- sample( 5:50, 1 )  #beware set replace=T if more than 1
    
  for(rot_or_not in 0:1)
  {  
    #to get rot_int of 0 every other run
    if (rot_or_not == 0) linputs$rot_interval <- 0
    
    
    ##################
    # run one scenario
    dfres <- do.call(run_rot, linputs)
    
    # summarise results per scenario
    # NOTE this is also currently calc at end of run_rot() prob better to calc there
    # and put in the output dfres, but its then repeated per 
    # TODO first AG fix this maybe go for non dplyr solution
    # if I do calc in run_rot then just find value at first row for each gene
    # Error in dplyr::filter(active_or_refuge == "active") : 
    # object 'active_or_refuge' not found
    res <- dfres %>%
    # only assess in control areas not in refugia  
    dplyr::filter(active_or_refuge=='active') %>%
    group_by(resist_gene) %>%
    # for all insecticides in all generations  
    # summarise(gens_under50 = sum(resistance < 0.5, na.rm=TRUE)) %>%
    # summarise(mean_gens_under50 = mean(gens_under50)) %>%
    # just for deployed insecticides 
    summarise(gens_dep_under50 = sum(resistance < 0.5 &
                                     #finds insecticide in use = this one
                                     resist_gene==paste0('insecticide',insecticide), na.rm=TRUE)) %>%
                                 summarise(tot_gens_dep_under50 = sum(gens_dep_under50)) %>%    
                                 unlist()
    
    #print scenario num and inputs to doc for exploration
    cat("scenario",i,
        " expo_hi",signif(linputs$expo_hi,2),
        " eff",signif(linputs$eff,2),
        " rot_interval",linputs$rot_interval,
        "\n")
    
    #print results in doc for diagnostics
    cat("tot gens deployed under freq 0.5 =", res,"\n\n")
    
    # create dataframe from inputs and outputs
    # first add scenario column onto results
    res$scenario <- i
    df_in_out <- as.data.frame(c(linputs, res))
    
    # rbind this scenario inputs & results onto previous
    # not a good speed or memory way of doing ... but a start
    df_res_all <- rbind(df_res_all, df_in_out)
    
  } #end rot_or_not loop
} #end scenario loop

# save object containing inputs and results as rda for analysis
save(df_res_all, file='df_res_all_rot.rda') #paste0(outFolder,'*.rda'))

```

\pagebreak

# summary plot of all runs, would show any differences between sequence & rotations as non horizontal lines

```{r, eval=TRUE, echo=FALSE, warning=FALSE, message=FALSE, fig.width=9, fig.height=6}

# want to plot line between sequence and rotation value
# any deviation from horizontal will be obvious
# could use rotation interval as the x axis, so that longer intervals will be clearer

# maybe not for publication
# but useful for quick view

    gg <- ggplot( df_res_all, aes_string(x='rot_interval',
                                         y='tot_gens_dep_under50',
                                         group='scenario',
                                         colour='scenario') ) +
          geom_line( alpha=0.5, lwd=1 )

    plot(gg)

```  
